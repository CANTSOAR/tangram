<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tangram Puzzle Game</title>
    <meta name="description" content="A classic tangram puzzle game playable in your browser. Solve puzzles of varying difficulty by arranging the seven geometric pieces.">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        /* styles.css */
        :root {
            --bg-color: #1a1a2e;
            --surface-color: #16213e;
            --primary-color: #0f3460;
            --secondary-color: #e94560;
            --text-color: #dcdcdc;
            --highlight-color: #ffffff;
            --shadow-color: rgba(0, 0, 0, 0.5);
            --font-family: 'Inter', sans-serif;

            --piece-lt1: #ff6b6b;
            --piece-lt2: #f06595;
            --piece-mt: #a0c4ff;
            --piece-st1: #845ef7;
            --piece-st2: #5c7cfa;
            --piece-sq: #48bfe3;
            --piece-p: #51cf66;

            --ease-out-quad: cubic-bezier(0.25, 0.46, 0.45, 0.94);
            --ease-in-out-circ: cubic-bezier(0.785, 0.135, 0.15, 0.86);
        }

        html[data-theme="high-contrast"] {
            --bg-color: #000000;
            --surface-color: #111111;
            --primary-color: #00ffff;
            --secondary-color: #ffff00;
            --text-color: #ffffff;
            --highlight-color: #ffffff;
            
            --piece-lt1: #ff0000;
            --piece-lt2: #00ff00;
            --piece-mt: #0000ff;
            --piece-st1: #ffff00;
            --piece-st2: #ff00ff;
            --piece-sq: #00ffff;
            --piece-p: #ffa500;
        }

        *, *::before, *::after {
            box-sizing: border-box;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: var(--font-family);
            background-color: var(--bg-color);
            color: var(--text-color);
        }

        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 1rem;
        }
        
        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
                scroll-behavior: auto !important;
            }
        }
        
        .game-container {
            display: grid;
            grid-template-columns: 250px 1fr 200px;
            grid-template-rows: auto 1fr;
            grid-template-areas:
                "header header header"
                "levels board controls";
            width: 100%;
            max-width: 1400px;
            height: 100%;
            max-height: 90vh;
            gap: 1rem;
            background: var(--surface-color);
            border-radius: 16px;
            box-shadow: 0 10px 30px var(--shadow-color);
            padding: 1rem;
        }
        
        /* Mobile Layout */
        @media (max-width: 900px) {
            body { padding: 0.5rem; }
            .game-container {
                grid-template-columns: 1fr;
                grid-template-rows: auto auto 1fr auto;
                grid-template-areas:
                    "header"
                    "levels"
                    "board"
                    "controls";
                max-height: none;
                height: 100%;
                border-radius: 0;
                padding: 0.5rem;
                gap: 0.5rem;
            }
        }
        
        .game-header {
            grid-area: header;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 1rem;
            background: var(--primary-color);
            border-radius: 8px;
        }
        
        .game-header h1 {
            margin: 0;
            font-size: 1.5rem;
            color: var(--highlight-color);
        }

        .status-bar {
            display: flex;
            gap: 1.5rem;
            font-size: 1.1rem;
        }
        
        #level-name { font-weight: bold; }

        .level-selector {
            grid-area: levels;
            display: flex;
            flex-direction: column;
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
            padding: 0.5rem;
            overflow-y: auto;
        }
        
        .difficulty-tabs {
            display: flex;
            margin-bottom: 0.5rem;
        }

        .tab-btn {
            flex-grow: 1;
            padding: 0.75rem 0.5rem;
            border: none;
            background: transparent;
            color: var(--text-color);
            font-weight: 600;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            transition: all 0.2s var(--ease-out-quad);
        }

        .tab-btn.active {
            color: var(--secondary-color);
            border-bottom-color: var(--secondary-color);
        }
        
        #level-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        #level-list li {
            padding: 0.75rem 1rem;
            margin: 0.25rem 0;
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.2s var(--ease-out-quad);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #level-list li:hover, #level-list li.active {
            background-color: var(--primary-color);
        }
        
        .stars-display { color: #ffd700; }

        .game-board-container {
            grid-area: board;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--bg-color);
            border-radius: 8px;
            overflow: hidden;
            position: relative;
        }

        #game-board {
            width: 100%;
            height: 100%;
            touch-action: none; /* Prevents browser default touch actions */
        }

        .tangram-piece {
            cursor: grab;
            transition: transform 150ms var(--ease-out-quad), filter 150ms var(--ease-out-quad);
            -webkit-tap-highlight-color: transparent; /* Disable highlight on mobile tap */
        }
        
        .tangram-piece.selected {
            cursor: grabbing;
            filter: drop-shadow(0 0 15px var(--highlight-color)) scale(1.03);
            stroke: var(--highlight-color);
            stroke-width: 2;
            stroke-linejoin: round;
        }
        
        .tangram-piece.snapped {
            cursor: default;
            filter: drop-shadow(0 0 5px var(--secondary-color));
        }

        .tangram-piece.dragging {
            transition: none;
        }

        #silhouette {
            fill: var(--primary-color);
            opacity: 0.8;
            filter: drop-shadow(0 5px 15px rgba(0,0,0,0.3));
        }
        
        .controls {
            grid-area: controls;
            display: flex;
            flex-direction: column;
            justify-content: center;
            gap: 0.75rem;
            padding: 1rem;
        }

        .control-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0.75rem 1.25rem;
            border: 2px solid var(--primary-color);
            background-color: transparent;
            color: var(--text-color);
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s var(--ease-out-quad);
        }

        .control-btn:hover, .control-btn:focus {
            background-color: var(--primary-color);
            color: var(--highlight-color);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        
        .control-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        @media (max-width: 900px) {
            .controls {
                flex-direction: row;
                justify-content: space-around;
                flex-wrap: wrap;
                background: rgba(0,0,0,0.2);
                border-radius: 8px;
                padding: 0.5rem;
            }
            .control-btn {
                padding: 0.75rem 0.5rem;
                font-size: 0.8rem;
                flex-grow: 1;
            }
        }

        /* Modal Styles */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s, visibility 0.3s;
        }
        
        .modal.show {
            opacity: 1;
            visibility: visible;
        }

        .modal-content {
            position: relative;
            background-color: var(--surface-color);
            padding: 2rem;
            border-radius: 16px;
            text-align: center;
            box-shadow: 0 5px 25px var(--shadow-color);
            transform: scale(0.9);
            transition: transform 0.3s var(--ease-in-out-circ);
            max-width: 500px;
            width: 90%;
        }
        
        .modal.show .modal-content {
            transform: scale(1);
        }

        .close-modal-btn {
            position: absolute;
            top: 10px;
            right: 15px;
            background: transparent;
            border: none;
            font-size: 2rem;
            font-weight: bold;
            color: var(--text-color);
            cursor: pointer;
            line-height: 1;
            padding: 0;
            margin: 0;
            opacity: 0.7;
            transition: opacity 0.2s;
        }
        .close-modal-btn:hover {
            opacity: 1;
        }
        
        .modal-content h2 {
            color: var(--secondary-color);
            font-size: 2rem;
            margin-top: 0;
            margin-bottom: 1.5rem;
        }
        
        #victory-stars {
            font-size: 3rem;
            color: #ffd700;
            margin: 1rem 0;
        }
        
        .modal button {
            padding: 0.75rem 2rem;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            margin: 0.5rem;
            background-color: var(--secondary-color);
            color: var(--highlight-color);
            transition: background-color 0.2s;
        }

        .modal button:hover {
            background-color: #c82333;
        }
        
        .modal input[type="text"] {
            padding: 0.75rem;
            width: 80%;
            margin: 1rem 0;
            border-radius: 8px;
            border: 2px solid var(--primary-color);
            background: var(--bg-color);
            color: var(--text-color);
            font-size: 1.1rem;
            text-align: center;
        }
        
        #name-error {
            color: var(--secondary-color);
            min-height: 1.2em;
            font-weight: 600;
        }

        .settings-grid {
            display: grid;
            grid-template-columns: 1fr auto;
            gap: 1rem;
            align-items: center;
            text-align: left;
        }

        .settings-grid label {
            font-weight: 600;
        }

        #reset-progress-btn {
            grid-column: 1 / -1;
            margin-top: 1rem;
            background-color: #6c757d;
        }
        
        #instructions-content {
            text-align: left;
            white-space: pre-wrap;
            background-color: rgba(0,0,0,0.2);
            padding: 1rem;
            border-radius: 8px;
            max-height: 50vh;
            overflow-y: auto;
            font-family: monospace;
        }

        /* Leaderboard styles */
        #leaderboard-content h3 {
            margin-top: 1.5rem;
            margin-bottom: 0.5rem;
            color: var(--secondary-color);
            border-bottom: 2px solid var(--primary-color);
            padding-bottom: 0.5rem;
        }
        #leaderboard-content ol {
            list-style-type: none;
            padding: 0;
        }
         #leaderboard-content li {
            display: grid;
            grid-template-columns: 2fr 3fr 1fr 1fr;
            padding: 0.5rem;
            border-radius: 4px;
        }
        #leaderboard-content li:nth-child(odd) {
            background: rgba(0,0,0,0.1);
        }
        #leaderboard-content .leaderboard-header {
            font-weight: bold;
            color: var(--highlight-color);
        }
        
        /* Piece patterns for color-blind friendly mode */
        .pattern-stripes { fill: url(#stripes); }
        .pattern-dots { fill: url(#dots); }
        .pattern-grid { fill: url(#grid); }
        .pattern-diagonals { fill: url(#diagonals); }
        
        /* Victory animation */
        @keyframes confetti-burst {
            0% { transform: translateY(0) rotate(0deg); opacity: 1; }
            100% { transform: translateY(200px) rotate(360deg); opacity: 0; }
        }
        
        .confetti {
            position: absolute;
            width: 10px;
            height: 10px;
            background-color: red;
            opacity: 0;
            animation: confetti-burst 2s ease-out forwards;
        }

    </style>
</head>
<body>

    <div class="game-container">
        <header class="game-header">
            <h1>Tangram</h1>
            <div class="status-bar">
                <span id="level-name">Select a Level</span>
                <span id="timer">00:00</span>
                <span id="completion">0/7</span>
            </div>
        </header>

        <aside class="level-selector">
            <div class="difficulty-tabs">
                <button class="tab-btn active" data-difficulty="easy">Easy</button>
                <button class="tab-btn" data-difficulty="medium">Medium</button>
                <button class="tab-btn" data-difficulty="hard">Hard</button>
            </div>
            <ul id="level-list">
                <!-- Levels will be dynamically inserted here -->
            </ul>
        </aside>

        <main class="game-board-container" id="board-container">
            <svg id="game-board" viewBox="0 0 600 600" preserveAspectRatio="xMidYMid meet">
                 <defs>
                     <!-- Patterns for colorblind accessibility -->
                     <pattern id="stripes" patternUnits="userSpaceOnUse" width="10" height="10">
                         <path d="M-1,1 l2,-2 M0,10 l10,-10 M9,11 l2,-2" stroke="rgba(255,255,255,0.4)" stroke-width="1"/>
                     </pattern>
                      <pattern id="dots" patternUnits="userSpaceOnUse" width="10" height="10">
                         <circle cx="5" cy="5" r="2" fill="rgba(255,255,255,0.6)" />
                     </pattern>
                     <pattern id="grid" patternUnits="userSpaceOnUse" width="10" height="10">
                         <path d="M 5 0 L 5 10 M 0 5 L 10 5" stroke="rgba(255,255,255,0.4)" stroke-width="1"/>
                     </pattern>
                     <pattern id="diagonals" patternUnits="userSpaceOnUse" width="10" height="10">
                         <path d="M 0 0 L 10 10 M 10 0 L 0 10" stroke="rgba(255,255,255,0.4)" stroke-width="1"/>
                     </pattern>
                 </defs>
                <g id="silhouette-group"></g>
                <g id="pieces-group"></g>
                <g id="hint-group"></g>
            </svg>
        </main>

        <aside class="controls">
            <button class="control-btn" id="reset-btn" title="Reset Puzzle">Reset</button>
            <button class="control-btn" id="undo-btn" title="Undo (Ctrl+Z)" disabled>Undo</button>
            <button class="control-btn" id="hint-btn" title="Get a Hint">Hint</button>
            <button class="control-btn" id="leaderboard-btn" title="Leaderboard">Leaderboard</button>
            <button class="control-btn" id="instructions-btn" title="How to Play">How to Play</button>
            <button class="control-btn" id="settings-btn" title="Settings">Settings</button>
        </aside>

    </div>

    <!-- Modals -->
    <div id="name-modal" class="modal show">
        <div class="modal-content">
            <h2>Enter Your Name</h2>
            <p>Please enter a name to save your scores to the leaderboard.</p>
            <input type="text" id="name-input" placeholder="Your Name" autocomplete="off" />
            <p id="name-error"></p>
            <button id="name-submit-btn">Start Playing</button>
        </div>
    </div>

    <div id="leaderboard-modal" class="modal">
        <div class="modal-content" style="max-width: 800px;">
            <h2>Leaderboard</h2>
            <div id="leaderboard-content" style="text-align: left; max-height: 60vh; overflow-y: auto;">
                <!-- Leaderboard content will be generated here -->
            </div>
            <button id="close-leaderboard-btn">Close</button>
        </div>
    </div>

    <div id="victory-modal" class="modal">
        <div class="modal-content">
            <button class="close-modal-btn" id="close-victory-btn" title="Close">&times;</button>
            <h2>Puzzle Complete!</h2>
            <div id="victory-stars"></div>
            <p>Time: <span id="victory-time"></span></p>
            <p>Best Time: <span id="victory-best-time"></span></p>
            <button id="next-level-btn">Next Level</button>
        </div>
    </div>
    
    <div id="settings-modal" class="modal">
        <div class="modal-content">
            <h2>Settings</h2>
            <div class="settings-grid">
                <label for="high-contrast-toggle">High Contrast Mode</label>
                <input type="checkbox" id="high-contrast-toggle" />
            </div>
             <button id="reset-progress-btn">Reset All Progress</button>
            <button id="close-settings-btn">Close</button>
        </div>
    </div>

    <div id="instructions-modal" class="modal">
        <div class="modal-content">
            <h2>How to Play</h2>
            <pre id="instructions-content"></pre>
            <button id="close-instructions-btn">Close</button>
        </div>
    </div>
    
    <div id="readme-container" style="display:none;">
        <pre>
GOAL: Arrange the seven pieces to fill the silhouette.

--- DESKTOP CONTROLS ---
Move: Click and drag a piece.
Rotate: Mouse wheel OR Q/E keys.
Flip: F key (parallelogram only).
Nudge: Arrow keys. Hold Shift to nudge faster.
Select: Click a piece.
Deselect: Click the background.

--- MOBILE CONTROLS ---
Move: Touch and drag.
Rotate: Two-finger rotate gesture.
Double-Tap: Rotate piece 45° clockwise.
Long-Press: Flip the parallelogram.
Select/Deselect: Tap a piece.
        </pre>
    </div>


    <script>
    // main.js
    document.addEventListener('DOMContentLoaded', () => {

        // --- BACKEND API CONFIGURATION ---
        const API_ENDPOINT_URL = 'https://tangram-backend.vercel.app/api/update-leaderboard';

        // This URL has been updated with the one you provided.
        const LEADERBOARD_BLOB_URL = 'https://qfershxgczealf0k.public.blob.vercel-storage.com/leaderboard.json';


        // --- GAME STATE & CONSTANTS ---
        const SVG_NAMESPACE = "http://www.w3.org/2000/svg";
        const BOARD_SIZE = 600;
        const SNAP_THRESHOLD_EASY = { pos: 20, rot: 10 };
        const SNAP_THRESHOLD_MEDIUM = { pos: 15, rot: 5 };
        const SNAP_THRESHOLD_HARD = { pos: 10, rot: 2.5 };
        
        let gameState = {
            levels: [],
            currentLevelId: null,
            pieces: [],
            selectedPiece: null,
            timerInterval: null,
            startTime: 0,
            hintsUsed: 0,
            history: [],
            historyIndex: -1,
            playerProgress: {}, // { levelId: { bestTime: 123, stars: 3 } }
            leaderboardData: {}, // { levelId: [ {id, time, stars}, ... ] }
            currentPlayerName: null,
        };

        const pieceDefinitions = {
            largeTriangle1: { path: "M 0 0 L 200 0 L 0 200 Z", color: 'var(--piece-lt1)', id: 'largeTriangle1', pattern: 'pattern-stripes' },
            largeTriangle2: { path: "M 0 0 L 200 0 L 0 200 Z", color: 'var(--piece-lt2)', id: 'largeTriangle2', pattern: 'pattern-diagonals' },
            mediumTriangle: { path: "M 0 0 L 100 100 L -100 100 Z", color: 'var(--piece-mt)', id: 'mediumTriangle', pattern: 'pattern-dots' },
            smallTriangle1: { path: "M 0 0 L 100 0 L 0 100 Z", color: 'var(--piece-st1)', id: 'smallTriangle1' },
            smallTriangle2: { path: "M 0 0 L 100 0 L 0 100 Z", color: 'var(--piece-st2)', id: 'smallTriangle2' },
            square: { path: "M 0 0 L 100 0 L 100 100 L 0 100 Z", color: 'var(--piece-sq)', id: 'square', pattern: 'pattern-grid' },
            parallelogram: { path: "M 0 0 L 100 0 L 200 100 L 100 100 Z", color: 'var(--piece-p)', id: 'parallelogram' }
        };
        
        // --- DOM ELEMENTS ---
        const board = document.getElementById('game-board');
        const boardContainer = document.getElementById('board-container');
        const piecesGroup = document.getElementById('pieces-group');
        const silhouetteGroup = document.getElementById('silhouette-group');
        const hintGroup = document.getElementById('hint-group');
        const levelList = document.getElementById('level-list');
        const difficultyTabs = document.querySelector('.difficulty-tabs');
        const levelNameEl = document.getElementById('level-name');
        const timerEl = document.getElementById('timer');
        const completionEl = document.getElementById('completion');
        const undoBtn = document.getElementById('undo-btn');
        const resetBtn = document.getElementById('reset-btn');
        const hintBtn = document.getElementById('hint-btn');
        const settingsBtn = document.getElementById('settings-btn');
        const instructionsBtn = document.getElementById('instructions-btn');
        const leaderboardBtn = document.getElementById('leaderboard-btn');
        
        // Modals
        const victoryModal = document.getElementById('victory-modal');
        const nextLevelBtn = document.getElementById('next-level-btn');
        const closeVictoryBtn = document.getElementById('close-victory-btn');
        const settingsModal = document.getElementById('settings-modal');
        const closeSettingsBtn = document.getElementById('close-settings-btn');
        const highContrastToggle = document.getElementById('high-contrast-toggle');
        const resetProgressBtn = document.getElementById('reset-progress-btn');
        const instructionsModal = document.getElementById('instructions-modal');
        const closeInstructionsBtn = document.getElementById('close-instructions-btn');
        const instructionsContent = document.getElementById('instructions-content');
        const nameModal = document.getElementById('name-modal');
        const nameInput = document.getElementById('name-input');
        const nameSubmitBtn = document.getElementById('name-submit-btn');
        const nameError = document.getElementById('name-error');
        const leaderboardModal = document.getElementById('leaderboard-modal');
        const closeLeaderboardBtn = document.getElementById('close-leaderboard-btn');
        const leaderboardContent = document.getElementById('leaderboard-content');

        // --- DATA ---
        const levelsData = [
            { id: "easy-house", difficulty: "easy", name: "House", targetPath: `M 100 300 L 150 250 L 150 150 L 250 50 L 250 150 L 300 100 L 500 300 L 450 300 L 450 400 L 150 400 L 150 300 Z`, initialPieceStates: [ { piece: "largeTriangle1", x: 50, y: 50 }, { piece: "largeTriangle2", x: 400, y: 50 }, { piece: "mediumTriangle", x: 50, y: 450 }, { piece: "smallTriangle1", x: 450, y: 450 }, { piece: "smallTriangle2", x: 50, y: 300 }, { piece: "square", x: 500, y: 250 }, { piece: "parallelogram", x: 250, y: 500 } ], canonicalSolution: [ { piece: "largeTriangle1", x: 300, y: 300, rotation: 180 }, { piece: "largeTriangle2", x: 300, y: 300, rotation: 270 }, { piece: "square", x: 350, y: 300, rotation: 0 }, { piece: "mediumTriangle", x: 250, y: 400, rotation: 180 }, { piece: "smallTriangle1", x: 150, y: 400, rotation: 270 }, { piece: "smallTriangle2", x: 350, y: 400, rotation: 180 }, { piece: "parallelogram", x: 250, y: 50, rotation: 90 } ] },
            { id: "medium-swan", difficulty: "medium", name: "Swan", targetPath: `M 150 400 L 150 300 L 179.29 270.71 L 108.58 200 L 37.86 270.71 L 37.86 129.29 L 179.29 129.29 L 250 200 L 250 300 L 350 200 L 550 200 L 350 400 L 450 400 L 450 500 L 350 400 L 350 500 L 250 500 L 350 400 Z`, initialPieceStates: [ { piece: "largeTriangle1", x: 50, y: 50 }, { piece: "largeTriangle2", x: 400, y: 50 }, { piece: "mediumTriangle", x: 50, y: 450 }, { piece: "smallTriangle1", x: 450, y: 450 }, { piece: "smallTriangle2", x: 50, y: 300 }, { piece: "square", x: 500, y: 250 }, { piece: "parallelogram", x: 250, y: 500 } ], canonicalSolution: [ { piece: "largeTriangle1", x: 350, y: 400, rotation: 180 }, { piece: "largeTriangle2", x: 350, y: 200, rotation: 0 }, { piece: "mediumTriangle", x: 37.86, y: 129.29, rotation: -45 }, { piece: "smallTriangle1", x: 350, y: 500, rotation: 180 }, { piece: "smallTriangle2", x: 450, y: 400, rotation: 90 }, { piece: "square", x: 179.29, y: 129.29, rotation: 45 }, { piece: "parallelogram", x: 150, y: 400, rotation: 270 } ] },
            { id: "hard-rabbit", difficulty: "hard", name: "Rabbit", targetPath: `M 150 300 L 250 400 L 214.64 435.36 L 356.07 435.36 L 285.36 364.64 L 308.58 341.42 L 591.42 341.42 L 520.71 270.71 L 591.42 200 L 520.71 129.28 L 450 58.58 L 308.58 58.58 L 379.29 129.28 L 520.71 129.28 L 450 200 L 250 200 L 185.36 264.64 L 43.93 264.64 L 114.64 335.36 Z`, initialPieceStates: [ { piece: "largeTriangle1", x: 50, y: 50 }, { piece: "largeTriangle2", x: 400, y: 50 }, { piece: "mediumTriangle", x: 50, y: 450 }, { piece: "smallTriangle1", x: 450, y: 450 }, { piece: "smallTriangle2", x: 50, y: 300 }, { piece: "square", x: 500, y: 250 }, { piece: "parallelogram", x: 250, y: 500 } ], canonicalSolution: [ { piece: "largeTriangle1", x: 250, y: 200, rotation: 0 }, { piece: "largeTriangle2", x: 450, y: 200, rotation: 45 }, { piece: "mediumTriangle", x: 150, y: 300, rotation: -90 }, { piece: "smallTriangle1", x: 114.64, y: 335.36, rotation: -135 }, { piece: "smallTriangle2", x: 285.36, y: 364.64, rotation: 45 }, { piece: "square", x: 520.71, y: 129.28, rotation: 45 }, { piece: "parallelogram", x: 520.71, y: 129.28, rotation: 45, flipped: true } ] }
        ];
        
        let dragState = {};
        let gestureState = {};
        let longPressTimeout = null;
        let lastTapInfo = { time: 0, pieceId: null };
        const DOUBLE_TAP_DELAY = 300; // ms
        const LONG_PRESS_DELAY = 500; // ms

        const getSVGPoint = (evt) => {
            const pt = board.createSVGPoint();
            const touch = evt.touches ? evt.touches[0] : evt;
            pt.x = touch.clientX;
            pt.y = touch.clientY;
            return pt.matrixTransform(board.getScreenCTM().inverse());
        };

        const onPointerDown = (e, piece) => {
            if (e.button !== 0 && e.type === 'mousedown') return;
            if (piece.snapped) return;

            selectPiece(piece);
            piece.el.classList.add('dragging');
            const startPoint = getSVGPoint(e);
            dragState = {
                piece,
                dragging: true,
                offset: { x: startPoint.x - piece.x, y: startPoint.y - piece.y }
            };
        };

        const onPointerMove = (e) => {
            if (!dragState.dragging) return;
            const currentPoint = getSVGPoint(e);
            const piece = dragState.piece;
            piece.x = currentPoint.x - dragState.offset.x;
            piece.y = currentPoint.y - dragState.offset.y;
            updatePieceTransform(piece);
        };

        const onPointerUp = (e) => {
            if (dragState.dragging) {
                if (dragState.piece) {
                    dragState.piece.el.classList.remove('dragging');
                    checkAndSnap(dragState.piece);
                    if(!dragState.piece.snapped) {
                        saveStateToHistory();
                    }
                }
            }
            dragState = {};
        };
        
        // --- MOBILE GESTURE HANDLING ---
        function onTouchStart(e, piece) {
            if (piece.snapped) {
                e.preventDefault();
                return;
            }
            if (e.touches.length === 2) {
                clearTimeout(longPressTimeout);
                e.preventDefault();
                selectPiece(piece);
                dragState = {}; // disable dragging
                const t1 = e.touches[0];
                const t2 = e.touches[1];
                const dx = t2.clientX - t1.clientX;
                const dy = t2.clientY - t1.clientY;
                gestureState = { piece, rotating: true, initialAngle: Math.atan2(dy, dx) * (180 / Math.PI), startRotation: piece.rotation };
                return;
            }
            if (e.touches.length === 1) {
                e.preventDefault();
                const currentTime = new Date().getTime();
                if (currentTime - lastTapInfo.time < DOUBLE_TAP_DELAY && piece.id === lastTapInfo.pieceId) {
                    clearTimeout(longPressTimeout);
                    lastTapInfo = { time: 0, pieceId: null };
                    if (dragState.piece) {
                        dragState.piece.el.classList.remove('dragging');
                    }
                    piece.rotation = (piece.rotation + 45) % 360;
                    updatePieceTransform(piece);
                    saveStateToHistory();
                    dragState = {};
                } else {
                    lastTapInfo = { time: currentTime, pieceId: piece.id };
                    longPressTimeout = setTimeout(() => {
                        if (dragState.dragging) {
                            if (piece.id === 'parallelogram') {
                                piece.el.classList.remove('dragging');
                                piece.flipped = !piece.flipped;
                                updatePieceTransform(piece);
                                saveStateToHistory();
                                dragState = {};
                            }
                        }
                        longPressTimeout = null;
                    }, LONG_PRESS_DELAY);
                    onPointerDown(e, piece);
                }
            }
        }

        function onTouchMove(e) {
            if(longPressTimeout && dragState.dragging) {
                const startPoint = getSVGPoint(e);
                const dist = Math.hypot(startPoint.x - (dragState.piece.x + dragState.offset.x), startPoint.y - (dragState.piece.y + dragState.offset.y));
                if (dist > 5) { clearTimeout(longPressTimeout); longPressTimeout = null; }
            }
            if (gestureState.rotating && e.touches.length === 2) {
                e.preventDefault();
                const t1 = e.touches[0], t2 = e.touches[1];
                const dx = t2.clientX - t1.clientX, dy = t2.clientY - t1.clientY;
                const currentAngle = Math.atan2(dy, dx) * (180 / Math.PI);
                const angleDiff = currentAngle - gestureState.initialAngle;
                gestureState.piece.rotation = gestureState.startRotation + angleDiff;
                updatePieceTransform(gestureState.piece);
            } else { onPointerMove(e); }
        }

        function onTouchEnd(e) {
            if(longPressTimeout) { clearTimeout(longPressTimeout); longPressTimeout = null; }
            if (gestureState.rotating) { saveStateToHistory(); gestureState = {}; }
            onPointerUp(e);
        }

        // --- INITIALIZATION ---
        function init() {
            promptForName();
        }

        async function initializeGame() {
            gameState.levels = levelsData;
            loadProgress();
            loadSettings();
            await fetchLeaderboard();
            renderLevelList('easy');
            setupEventListeners();
            
            const lastLevel = localStorage.getItem('tangram_lastLevelId');
            if (lastLevel && gameState.levels.find(l => l.id === lastLevel)) {
                loadLevel(lastLevel);
            } else {
                loadLevel(gameState.levels.find(l => l.difficulty === 'easy').id);
            }
        }
        
        // --- LEVEL MANAGEMENT ---
        function loadLevel(levelId) {
            if (gameState.timerInterval) clearInterval(gameState.timerInterval);
            
            const level = gameState.levels.find(l => l.id === levelId);
            if (!level) { console.error("Level not found:", levelId); return; }
            
            gameState.currentLevelId = levelId;
            gameState.selectedPiece = null;
            gameState.hintsUsed = 0;
            gameState.history = [];
            gameState.historyIndex = -1;
            piecesGroup.innerHTML = '';
            silhouetteGroup.innerHTML = '';
            hintGroup.innerHTML = '';
            
            const path = document.createElementNS(SVG_NAMESPACE, 'path');
            path.setAttribute('d', level.targetPath);
            path.setAttribute('id', 'silhouette');
            silhouetteGroup.appendChild(path);

            gameState.pieces = level.initialPieceStates.map(pState => {
                const pieceDef = pieceDefinitions[pState.piece];
                const el = document.createElementNS(SVG_NAMESPACE, 'path');
                el.setAttribute('d', pieceDef.path);
                el.setAttribute('fill', pieceDef.color);
                el.classList.add('tangram-piece');
                el.dataset.id = pieceDef.id;
                const pieceObj = { id: pieceDef.id, el: el, x: pState.x, y: pState.y, rotation: pState.rotation || 0, flipped: pState.flipped || false, snapped: false };
                piecesGroup.appendChild(el);
                updatePieceTransform(pieceObj);
                addPieceEventListeners(pieceObj);
                return pieceObj;
            });
            
            updateUI();
            updateActiveLevelInList(levelId);
            startTimer();
            saveStateToHistory();
            localStorage.setItem('tangram_lastLevelId', levelId);
        }
        
        function renderLevelList(difficulty) {
            levelList.innerHTML = '';
            const filteredLevels = gameState.levels.filter(l => l.difficulty === difficulty);
            
            filteredLevels.forEach(level => {
                const li = document.createElement('li');
                li.textContent = level.name;
                li.dataset.levelId = level.id;
                
                const progress = gameState.playerProgress[level.id];
                if (progress) {
                    const stars = document.createElement('span');
                    stars.classList.add('stars-display');
                    stars.textContent = '★'.repeat(progress.stars) + '☆'.repeat(3 - progress.stars);
                    li.appendChild(stars);
                }
                
                li.addEventListener('click', () => loadLevel(level.id));
                levelList.appendChild(li);
            });
            updateActiveLevelInList(gameState.currentLevelId);
        }
        
        function updateActiveLevelInList(levelId) {
            const currentLevel = gameState.levels.find(l => l.id === levelId);
            if(!currentLevel) return;

            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.difficulty === currentLevel.difficulty);
            });
            document.querySelectorAll('#level-list li').forEach(li => {
                li.classList.toggle('active', li.dataset.levelId === levelId);
            });
        }
        
        // --- PIECE MANIPULATION ---
        function updatePieceTransform(piece) {
            const flip = piece.flipped ? 'scale(-1, 1)' : '';
            piece.el.setAttribute('transform', `translate(${piece.x} ${piece.y}) rotate(${piece.rotation}) ${flip}`);
        }
        
        function selectPiece(piece) {
            if (gameState.selectedPiece) {
                gameState.selectedPiece.el.classList.remove('selected');
            }
            if(piece && !piece.snapped) {
                gameState.selectedPiece = piece;
                piece.el.classList.add('selected');
                piecesGroup.appendChild(piece.el);
            } else {
                gameState.selectedPiece = null;
            }
        }
        
        function getSnapThresholds() {
            const difficulty = gameState.levels.find(l => l.id === gameState.currentLevelId)?.difficulty || 'medium';
            if (difficulty === 'easy') return SNAP_THRESHOLD_EASY;
            if (difficulty === 'hard') return SNAP_THRESHOLD_HARD;
            return SNAP_THRESHOLD_MEDIUM;
        }

        function checkAndSnap(piece) {
            if (piece.snapped) return;
            
            const level = gameState.levels.find(l => l.id === gameState.currentLevelId);
            const solution = level.canonicalSolution.find(s => s.piece === piece.id);
            if (!solution) return;
            const thresholds = getSnapThresholds();
            
            const dx = piece.x - solution.x;
            const dy = piece.y - solution.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            
            const rotDiff = Math.abs((piece.rotation || 0) - (solution.rotation || 0)) % 360;
            const angleDist = Math.min(rotDiff, 360 - rotDiff);
            
            const flippedState = piece.flipped || false;
            const solutionFlipped = solution.flipped || false;

            if (dist < thresholds.pos && angleDist < thresholds.rot && flippedState === solutionFlipped) {
                piece.x = solution.x;
                piece.y = solution.y;
                piece.rotation = solution.rotation || 0;
                piece.flipped = solution.flipped || false;
                piece.snapped = true;
                piece.el.classList.add('snapped');
                piece.el.classList.remove('selected');
                gameState.selectedPiece = null;
                updatePieceTransform(piece);
                updateUI();
                saveStateToHistory();
                checkWinCondition();
            }
        }
        
        // --- EVENT LISTENERS ---
        function setupEventListeners() {
            boardContainer.addEventListener('mousemove', onPointerMove);
            boardContainer.addEventListener('mouseup', onPointerUp);
            boardContainer.addEventListener('mouseleave', onPointerUp);
            boardContainer.addEventListener('touchmove', onTouchMove, { passive: false });
            boardContainer.addEventListener('touchend', onTouchEnd);
            boardContainer.addEventListener('touchcancel', onTouchEnd);
            
            board.addEventListener('click', (e) => {
                if (e.target === board || e.target === silhouetteGroup.firstChild) {
                    selectPiece(null);
                }
            });

            window.addEventListener('keydown', (e) => {
                if (!gameState.selectedPiece) return;
                
                const piece = gameState.selectedPiece;
                let moved = false;
                switch(e.key) {
                    case 'q': case 'Q': piece.rotation -= 15; moved = true; break;
                    case 'e': case 'E': piece.rotation += 15; moved = true; break;
                    case 'f': case 'F': 
                        if (piece.id === 'parallelogram') {
                            piece.flipped = !piece.flipped; moved = true;
                        }
                        break;
                    case 'ArrowUp': piece.y -= e.shiftKey ? 5 : 1; moved = true; break;
                    case 'ArrowDown': piece.y += e.shiftKey ? 5 : 1; moved = true; break;
                    case 'ArrowLeft': piece.x -= e.shiftKey ? 5 : 1; moved = true; break;
                    case 'ArrowRight': piece.x += e.shiftKey ? 5 : 1; moved = true; break;
                }
                if (moved) {
                    e.preventDefault();
                    updatePieceTransform(piece);
                    if(this.keyMoveTimeout) clearTimeout(this.keyMoveTimeout);
                    this.keyMoveTimeout = setTimeout(() => saveStateToHistory(), 200);
                }
            });

            difficultyTabs.addEventListener('click', (e) => {
                if (e.target.classList.contains('tab-btn') && !e.target.classList.contains('active')) {
                    const difficulty = e.target.dataset.difficulty;
                    document.querySelector('.tab-btn.active').classList.remove('active');
                    e.target.classList.add('active');
                    renderLevelList(difficulty);
                    const firstLevelOfDifficulty = gameState.levels.find(l => l.difficulty === difficulty);
                    if (firstLevelOfDifficulty) {
                        loadLevel(firstLevelOfDifficulty.id);
                    }
                }
            });

            resetBtn.addEventListener('click', () => loadLevel(gameState.currentLevelId));
            
            nextLevelBtn.addEventListener('click', () => {
                victoryModal.classList.remove('show');
                const currentIndex = gameState.levels.findIndex(l => l.id === gameState.currentLevelId);
                const currentDifficulty = gameState.levels[currentIndex].difficulty;
                const nextLevels = gameState.levels.filter(l => l.difficulty === currentDifficulty);
                const currentDifficultyIndex = nextLevels.findIndex(l => l.id === gameState.currentLevelId);
                
                if(currentDifficultyIndex < nextLevels.length - 1) {
                    loadLevel(nextLevels[currentDifficultyIndex + 1].id);
                } else if (currentIndex < gameState.levels.length - 1) {
                    loadLevel(gameState.levels[currentIndex + 1].id)
                }
            });

            undoBtn.addEventListener('click', undo);
            window.addEventListener('keydown', e => {
                if ((e.ctrlKey || e.metaKey) && e.key === 'z') { e.preventDefault(); undo(); }
            });
            
            hintBtn.addEventListener('click', provideHint);
            
            // Modals
            closeVictoryBtn.addEventListener('click', () => victoryModal.classList.remove('show'));
            settingsBtn.addEventListener('click', () => settingsModal.classList.add('show'));
            closeSettingsBtn.addEventListener('click', () => settingsModal.classList.remove('show'));
            settingsModal.addEventListener('click', (e) => { if (e.target === settingsModal) { settingsModal.classList.remove('show'); }});
            
            leaderboardBtn.addEventListener('click', () => { renderLeaderboard(); leaderboardModal.classList.add('show'); });
            closeLeaderboardBtn.addEventListener('click', () => leaderboardModal.classList.remove('show'));
            leaderboardModal.addEventListener('click', (e) => { if (e.target === leaderboardModal) { leaderboardModal.classList.remove('show'); }});

            highContrastToggle.addEventListener('change', (e) => {
                document.documentElement.setAttribute('data-theme', e.target.checked ? 'high-contrast' : 'default');
                saveSettings();
            });
            resetProgressBtn.addEventListener('click', () => {
                // This only resets local progress, not the server leaderboard.
                if(confirm('Are you sure you want to reset all your local progress (stars, best times)? This cannot be undone.')) {
                    localStorage.removeItem('tangram_progress');
                    localStorage.removeItem('tangram_lastLevelId');
                    gameState.playerProgress = {};
                    location.reload();
                }
            });
            
            instructionsBtn.addEventListener('click', () => {
                instructionsContent.textContent = document.querySelector('#readme-container pre').textContent;
                instructionsModal.classList.add('show');
            });
            closeInstructionsBtn.addEventListener('click', () => instructionsModal.classList.remove('show'));
            instructionsModal.addEventListener('click', (e) => { if (e.target === instructionsModal) { instructionsModal.classList.remove('show'); }});
        }
        
        function addPieceEventListeners(piece) {
            piece.el.addEventListener('mousedown', (e) => onPointerDown(e, piece));
            piece.el.addEventListener('touchstart', (e) => onTouchStart(e, piece), { passive: false });
            
            piece.el.addEventListener('wheel', (e) => {
                 if(piece.snapped) return;
                 e.preventDefault();
                 selectPiece(piece);
                 piece.rotation += e.deltaY > 0 ? 15 : -15;
                 updatePieceTransform(piece);
                 if(this.wheelTimeout) clearTimeout(this.wheelTimeout);
                 this.wheelTimeout = setTimeout(() => saveStateToHistory(), 200);
            });
        }
        
        // --- HINT SYSTEM ---
        function provideHint() {
            const level = gameState.levels.find(l => l.id === gameState.currentLevelId);
            const unsnappedPieces = gameState.pieces.filter(p => !p.snapped);
            if(unsnappedPieces.length === 0) return;
            
            const solutionOrder = level.canonicalSolution.map(s => s.piece);
            const nextPieceId = solutionOrder.find(id => unsnappedPieces.some(p => p.id === id));
            
            if (!nextPieceId) return;

            const pieceToHint = gameState.pieces.find(p => p.id === nextPieceId);
            const solution = level.canonicalSolution.find(s => s.piece === pieceToHint.id);
            
            gameState.hintsUsed++;
            hintGroup.innerHTML = '';

            if (gameState.hintsUsed % 3 === 1) {
                pieceToHint.el.style.filter = "drop-shadow(0 0 20px yellow)";
                setTimeout(() => { pieceToHint.el.style.filter = ""; }, 2000);
            } else if (gameState.hintsUsed % 3 === 2) {
                const ghostEl = pieceToHint.el.cloneNode();
                ghostEl.style.fill = 'yellow'; ghostEl.style.opacity = '0.5'; ghostEl.style.pointerEvents = 'none';
                const flip = (solution.flipped || false) ? 'scale(-1, 1)' : '';
                ghostEl.setAttribute('transform', `translate(${solution.x} ${solution.y}) rotate(${solution.rotation || 0}) ${flip}`);
                hintGroup.appendChild(ghostEl);
                setTimeout(() => { hintGroup.innerHTML = ''; }, 3000);
            } else {
                pieceToHint.x = solution.x; pieceToHint.y = solution.y;
                pieceToHint.rotation = solution.rotation || 0;
                pieceToHint.flipped = solution.flipped || false;
                updatePieceTransform(pieceToHint);
                checkAndSnap(pieceToHint);
            }
        }
        
        // --- GAME STATE & UI UPDATES ---
        
        function startTimer() {
            gameState.startTime = Date.now();
            gameState.timerInterval = setInterval(() => {
                const elapsed = Math.floor((Date.now() - gameState.startTime) / 1000);
                const minutes = String(Math.floor(elapsed / 60)).padStart(2, '0');
                const seconds = String(elapsed % 60).padStart(2, '0');
                timerEl.textContent = `${minutes}:${seconds}`;
            }, 1000);
        }
        
        function updateUI() {
            const snappedCount = gameState.pieces.filter(p => p.snapped).length;
            completionEl.textContent = `${snappedCount}/7`;
            
            const level = gameState.levels.find(l=>l.id === gameState.currentLevelId);
            if (level) { levelNameEl.textContent = level.name; }
        }
        
        async function checkWinCondition() {
            const allSnapped = gameState.pieces.every(p => p.snapped);
            if (allSnapped) {
                console.log("Win condition met! Preparing to submit score.");
                clearInterval(gameState.timerInterval);
                const timeTaken = Math.floor((Date.now() - gameState.startTime) / 1000);
                
                const stars = Math.max(1, 3 - gameState.hintsUsed);
                const progress = gameState.playerProgress[gameState.currentLevelId];

                let isNewBest = false;
                if (!progress || timeTaken < progress.bestTime) {
                    gameState.playerProgress[gameState.currentLevelId] = { bestTime: timeTaken, stars: Math.max(stars, progress?.stars || 0) };
                    isNewBest = true;
                } else if (stars > progress.stars) {
                     gameState.playerProgress[gameState.currentLevelId].stars = stars;
                }
                
                await submitScoreToLeaderboard(timeTaken, stars);
                saveProgress();
                showVictoryModal(timeTaken, isNewBest);
                renderLevelList(gameState.levels.find(l=>l.id === gameState.currentLevelId).difficulty);
            }
        }
        
        function showVictoryModal(timeTaken, isNewBest) {
            const progress = gameState.playerProgress[gameState.currentLevelId];
            document.getElementById('victory-time').textContent = timerEl.textContent;
            document.getElementById('victory-best-time').textContent = `${Math.floor(progress.bestTime / 60).toString().padStart(2,'0')}:${(progress.bestTime % 60).toString().padStart(2,'0')} ${isNewBest ? '(New Best!)' : ''}`;
            document.getElementById('victory-stars').textContent = '★'.repeat(progress.stars) + '☆'.repeat(3 - progress.stars);
            
            const currentIndex = gameState.levels.findIndex(l => l.id === gameState.currentLevelId);
            nextLevelBtn.style.display = (currentIndex < gameState.levels.length - 1) ? 'inline-block' : 'none';

            victoryModal.classList.add('show');
        }
        
        // --- HISTORY (UNDO) ---
        function saveStateToHistory() {
            const state = gameState.pieces.map(p => ({ id: p.id, x: p.x, y: p.y, rotation: p.rotation, flipped: p.flipped, snapped: p.snapped }));
            if (gameState.historyIndex < gameState.history.length - 1) {
                gameState.history = gameState.history.slice(0, gameState.historyIndex + 1);
            }
            gameState.history.push(state);
            if (gameState.history.length > 50) { gameState.history.shift(); }
            gameState.historyIndex = gameState.history.length - 1;
            undoBtn.disabled = gameState.historyIndex <= 0;
        }
        
        function undo() {
            if (gameState.historyIndex > 0) {
                gameState.historyIndex--;
                applyState(gameState.history[gameState.historyIndex]);
                undoBtn.disabled = gameState.historyIndex <= 0;
            }
        }
        
        function applyState(state) {
            state.forEach(pState => {
                const piece = gameState.pieces.find(p => p.id === pState.id);
                if (piece) {
                    Object.assign(piece, pState);
                    piece.el.classList.toggle('snapped', piece.snapped);
                    updatePieceTransform(piece);
                }
            });
            updateUI();
        }
        
        // --- NAME & LEADERBOARD ---
        function promptForName() {
            const savedName = localStorage.getItem('tangram_name');
            if (savedName) {
                gameState.currentPlayerName = savedName;
                nameModal.classList.remove('show');
                initializeGame();
                return;
            }

            const handleNameSubmission = () => {
                const name = nameInput.value.trim();
                if (name) {
                    gameState.currentPlayerName = name;
                    localStorage.setItem('tangram_name', name);
                    nameModal.classList.remove('show');
                    initializeGame();
                    
                    // Show instructions for the first time user
                    instructionsContent.textContent = document.querySelector('#readme-container pre').textContent;
                    instructionsModal.classList.add('show');
                } else {
                    nameError.textContent = 'Please enter a name.';
                }
            }
            nameSubmitBtn.addEventListener('click', handleNameSubmission);
            nameInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') handleNameSubmission();
            });
        }
        
        async function fetchLeaderboard() {
            if (LEADERBOARD_BLOB_URL.includes('<your-unique-hash-goes-here>')) {
                console.warn("Leaderboard fetch skipped: Using placeholder URL. Please complete a game to get your real URL.");
                gameState.leaderboardData = {};
                return;
            }

            try {
                // By adding a unique query parameter, we prevent the browser from using a cached version.
                const response = await fetch(`${LEADERBOARD_BLOB_URL}?cache_bust=${new Date().getTime()}`);
                if (!response.ok) {
                    if (response.status === 404) {
                       console.log("Leaderboard not found on server, starting fresh.");
                       gameState.leaderboardData = {};
                       return;
                    }
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                gameState.leaderboardData = await response.json();
            } catch (e) {
                console.error("Could not fetch leaderboard data:", e);
                gameState.leaderboardData = {};
            }
        }

        async function updateLeaderboard(data) {
             try {
                const response = await fetch(API_ENDPOINT_URL, {
                    method: 'POST',
                    mode: 'cors',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(data),
                });

                if (!response.ok) throw new Error(`API request failed with status: ${response.status}`);
                
                const responseData = await response.json();
                console.log('Leaderboard updated on server.', responseData);
                
                if (responseData.url) {
                    console.log('%cIMPORTANT: Your permanent leaderboard URL is:', 'color: yellow; font-size: 1.2em; font-weight: bold;');
                    console.log(`%c${responseData.url}`, 'color: cyan; font-size: 1.1em;');
                    console.log('%cCopy this URL and paste it into the LEADERBOARD_BLOB_URL constant in your HTML file.', 'color: yellow; font-weight: bold;');
                }

            } catch (error) {
                console.error('Failed to update leaderboard on server:', error);
                if (error instanceof TypeError && error.message.toLowerCase().includes('failed to fetch')) {
                     console.error(
                        '%cFETCH ERROR HINT: This usually means your backend API at ' + API_ENDPOINT_URL + ' is not configured for CORS. The browser is blocking the request for security reasons. Please check your Vercel API file and ensure it returns "Access-Control-Allow-Origin" headers.',
                        'color: orange; font-size: 1.1em; font-weight: bold;'
                    );
                }
            }
        }

        async function submitScoreToLeaderboard(time, stars) {
            if (!gameState.currentPlayerName) return;

            let levelScores = gameState.leaderboardData[gameState.currentLevelId] || [];
            const playerExistingScore = levelScores.find(s => s.id === gameState.currentPlayerName);

            // A new score is "best" if it has more stars, or same stars with a better (lower) time.
            const isNewBest = !playerExistingScore || stars > playerExistingScore.stars || (stars === playerExistingScore.stars && time < playerExistingScore.time);

            if (isNewBest) {
                console.log("New best score! Submitting to leaderboard.");
                const otherScores = levelScores.filter(s => s.id !== gameState.currentPlayerName);
                const newScore = { id: gameState.currentPlayerName, time, stars };
                const updatedScores = [...otherScores, newScore];
                
                // New sorting logic: Prioritize stars first (descending), then time (ascending).
                updatedScores.sort((a, b) => {
                    if (a.stars !== b.stars) return b.stars - a.stars;
                    return a.time - b.time;
                });
                
                gameState.leaderboardData[gameState.currentLevelId] = updatedScores;
                await updateLeaderboard(gameState.leaderboardData);
            } else {
                console.log("Score was not a new best. Not submitting.");
            }
        }
        
        function renderLeaderboard() {
            leaderboardContent.innerHTML = '';
            ['easy', 'medium', 'hard'].forEach(difficulty => {
                const section = document.createElement('div');
                section.innerHTML = `<h3>${difficulty.charAt(0).toUpperCase() + difficulty.slice(1)}</h3>`;
                
                const header = `<li class="leaderboard-header">
                    <span>Level</span><span>Name</span><span>Time</span><span>Stars</span>
                </li>`;

                const levelsForDifficulty = gameState.levels.filter(l => l.difficulty === difficulty);
                let contentHtml = '';

                levelsForDifficulty.forEach(level => {
                    const scores = gameState.leaderboardData[level.id] || [];
                    if (scores.length > 0) {
                       scores.slice(0, 10).forEach(score => { // Show top 10 per level
                            const minutes = String(Math.floor(score.time / 60)).padStart(2, '0');
                            const seconds = String(score.time % 60).padStart(2, '0');
                            const starDisplay = '★'.repeat(score.stars);
                            contentHtml += `<li>
                                <span>${level.name}</span>
                                <span>${score.id}</span>
                                <span>${minutes}:${seconds}</span>
                                <span class="stars-display">${starDisplay}</span>
                            </li>`;
                       });
                    }
                });

                if (contentHtml) {
                    section.innerHTML += `<ol>${header}${contentHtml}</ol>`;
                } else {
                    section.innerHTML += `<p>No scores recorded for this difficulty yet.</p>`;
                }
                leaderboardContent.appendChild(section);
            });
        }


        // --- DATA PERSISTENCE ---
        function saveProgress() {
            try { localStorage.setItem('tangram_progress', JSON.stringify(gameState.playerProgress)); } catch (e) { console.error("Could not save progress:", e); }
        }
        
        function loadProgress() {
            try {
                const progress = localStorage.getItem('tangram_progress');
                if (progress) gameState.playerProgress = JSON.parse(progress);
            } catch (e) { console.error("Could not load progress:", e); gameState.playerProgress = {}; }
        }
        
        function saveSettings() {
            // FIX: Corrected variable name from highToggle to highContrastToggle
            const settings = { highContrast: highContrastToggle.checked };
            localStorage.setItem('tangram_settings', JSON.stringify(settings));
        }

        function loadSettings() {
             try {
                const settings = JSON.parse(localStorage.getItem('tangram_settings'));
                if (settings) {
                    highContrastToggle.checked = settings.highContrast;
                    document.documentElement.setAttribute('data-theme', settings.highContrast ? 'high-contrast' : 'default');
                }
            } catch (e) { console.error("Could not load settings:", e); }
        }

        // --- RUN GAME ---
        init();
    });
    </script>
</body>
</html>

